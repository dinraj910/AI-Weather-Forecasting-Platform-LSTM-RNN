# -*- coding: utf-8 -*-
"""Multivariate_Weather_Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rYjt-UVwG7mqpUiMykP602qwnGFt2tfT

# Multivariate Weather Forecasting (Jena Climate)

Install Dependencies
"""

!pip install kaggle tensorflow scikit-learn matplotlib seaborn

"""Upload Kaggle API"""

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

"""Download Dataset"""

!kaggle datasets download -d mnassrib/jena-climate
!unzip jena-climate.zip

"""Imports"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau

"""Load Dataset"""

df = pd.read_csv("jena_climate_2009_2016.csv")

print(df.head())
print(df.shape)

"""Convert Date Column"""

df = pd.read_csv("jena_climate_2009_2016.csv") # Reload the DataFrame
df['Date Time'] = pd.to_datetime(df['Date Time'], format='%d.%m.%Y %H:%M:%S')
df.set_index('Date Time', inplace=True)

"""Downsample to Hourly"""

df_hourly = df.resample('1H').mean()

print(df_hourly.shape)

df_hourly = df_hourly.dropna()

df_hourly = df.resample('1H').mean()

# Handle missing values
df_hourly = df_hourly.interpolate(method='time')

# Final safety check
df_hourly = df_hourly.dropna()

print("Remaining NaNs:", df_hourly.isna().sum().sum())

"""Target & Features"""

target_col = 'T (degC)'

features = df_hourly.columns.tolist()
print(features)

"""Train-Test Split (Chronological)"""

train_size = int(len(df_hourly) * 0.8)

train_df = df_hourly.iloc[:train_size]
test_df = df_hourly.iloc[train_size:]

"""Scaling (Fit on Train Only)"""

scaler = MinMaxScaler()

train_scaled = scaler.fit_transform(train_df)
test_scaled = scaler.transform(test_df)

"""Sliding Window Creation"""

WINDOW_SIZE = 72

def create_sequences(data, window_size, target_index):
    X, y = [], []

    for i in range(window_size, len(data)):
        X.append(data[i-window_size:i])
        y.append(data[i, target_index])

    return np.array(X), np.array(y)

target_index = features.index(target_col)

X_train, y_train = create_sequences(train_scaled, WINDOW_SIZE, target_index)
X_test, y_test = create_sequences(test_scaled, WINDOW_SIZE, target_index)

print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)

"""Model Architecture"""

model = Sequential([
    LSTM(128, return_sequences=True, input_shape=(WINDOW_SIZE, len(features))),
    Dropout(0.2),
    LSTM(64),
    Dropout(0.2),
    Dense(32, activation='relu'),
    Dense(1)
])

model.compile(
    optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
    loss='mse'
)

model.summary()

"""Callbacks"""

early_stop = EarlyStopping(
    monitor='val_loss',
    patience=5,
    restore_best_weights=True
)

lr_scheduler = ReduceLROnPlateau(
    monitor='val_loss',
    factor=0.5,
    patience=3
)

"""Train"""

history = model.fit(
    X_train,
    y_train,
    validation_split=0.1,
    epochs=30,
    batch_size=64,
    callbacks=[early_stop, lr_scheduler]
)

"""Predict"""

predictions = model.predict(X_test)

"""Inverse Scaling"""

temp_min = scaler.data_min_[target_index]
temp_max = scaler.data_max_[target_index]

y_test_actual = y_test * (temp_max - temp_min) + temp_min
pred_actual = predictions.flatten() * (temp_max - temp_min) + temp_min

"""Evaluation"""

rmse = np.sqrt(mean_squared_error(y_test_actual, pred_actual))
mae = mean_absolute_error(y_test_actual, pred_actual)

print("RMSE:", rmse)
print("MAE:", mae)

plt.figure(figsize=(15, 6))
plt.plot(y_test_actual, label='Actual Temperature')
plt.plot(pred_actual, label='Predicted Temperature')
plt.title('Actual vs Predicted Temperature')
plt.xlabel('Time Step')
plt.ylabel('Temperature (degC)')
plt.legend()
plt.show()

"""Save Model"""

model.save("weather_lstm_model.h5")

from google.colab import files
files.download("weather_lstm_model.h5")

"""Test Sample Forecast"""

last_window = test_scaled[-WINDOW_SIZE:]
X_sample = np.array([last_window])

next_temp_scaled = model.predict(X_sample)
next_temp = next_temp_scaled[0][0] * (temp_max - temp_min) + temp_min

print("Predicted next-hour temperature:", next_temp)

"""Predict Next 7 Days"""

# Number of hours to forecast
FORECAST_HOURS = 48  # 7 days

# Get last window from full dataset
last_window = test_scaled[-WINDOW_SIZE:].copy()

future_predictions_scaled = []

current_window = last_window.copy()

for _ in range(FORECAST_HOURS):

    # Predict next temperature (scaled)
    pred_scaled = model.predict(np.array([current_window]), verbose=0)[0][0]

    # Store prediction
    future_predictions_scaled.append(pred_scaled)

    # Create next input row
    next_row = current_window[-1].copy()

    # Replace temperature value with predicted value
    next_row[target_index] = pred_scaled

    # Update window
    current_window = np.vstack((current_window[1:], next_row))

# Convert to numpy
future_predictions_scaled = np.array(future_predictions_scaled)

"""Inverse Scale to Actual Temperature"""

temp_min = scaler.data_min_[target_index]
temp_max = scaler.data_max_[target_index]

future_predictions = future_predictions_scaled * (temp_max - temp_min) + temp_min

print("Next 7 days (hourly) temperature forecast:")
print(future_predictions[:24])  # First day preview

"""Plot Next Week Forecast"""

plt.figure(figsize=(14,6))

# Plot last 5 days historical
historical_hours = 120
plt.plot(
    df_hourly[target_col].iloc[-historical_hours:].values,
    label="Last 5 Days Actual"
)

# Plot forecast
future_index = range(historical_hours, historical_hours + FORECAST_HOURS)

plt.plot(
    future_index,
    future_predictions,
    label="Next 7 Days Forecast"
)

plt.legend()
plt.title("7-Day Temperature Forecast (Hourly)")
plt.show()

"""# multivariate dynamic forecasting system

Modify Sequence Creation
"""

WINDOW_SIZE = 72

def create_sequences_multi(data, window_size):
    X, y = [], []

    for i in range(window_size, len(data)):
        X.append(data[i-window_size:i])
        y.append(data[i])   # full feature vector

    return np.array(X), np.array(y)

X_train, y_train = create_sequences_multi(train_scaled, WINDOW_SIZE)
X_test, y_test = create_sequences_multi(test_scaled, WINDOW_SIZE)

print("X_train:", X_train.shape)
print("y_train:", y_train.shape)

"""Build Multi-Output LSTM"""

model = Sequential([
    LSTM(128, return_sequences=True, input_shape=(WINDOW_SIZE, len(features))),
    Dropout(0.2),
    LSTM(64),
    Dropout(0.2),
    Dense(64, activation='relu'),
    Dense(len(features))   # predict ALL features
])

model.compile(
    optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
    loss='mse'
)

model.summary()

"""Train"""

history = model.fit(
    X_train,
    y_train,
    validation_split=0.1,
    epochs=30,
    batch_size=64,
    callbacks=[early_stop, lr_scheduler]
)

"""Evaluate Temperature Only"""

predictions = model.predict(X_test)

# Inverse scaling entire feature vector
pred_actual = scaler.inverse_transform(predictions)
y_test_actual = scaler.inverse_transform(y_test)

temp_idx = features.index('T (degC)')

rmse = np.sqrt(mean_squared_error(
    y_test_actual[:, temp_idx],
    pred_actual[:, temp_idx]
))

mae = mean_absolute_error(
    y_test_actual[:, temp_idx],
    pred_actual[:, temp_idx]
)

print("Temperature RMSE:", rmse)
print("Temperature MAE:", mae)

plt.figure(figsize=(15, 6))
plt.plot(y_test_actual[:, temp_idx], label='Actual Temperature')
plt.plot(pred_actual[:, temp_idx], label='Predicted Temperature')
plt.title('Actual vs Predicted Temperature (Multi-Output LSTM)')
plt.xlabel('Time Step')
plt.ylabel('Temperature (degC)')
plt.legend()
plt.show()

"""7-Day Recursive Forecast"""

FORECAST_HOURS = 168

last_window = test_scaled[-WINDOW_SIZE:].copy()

future_predictions_scaled = []
current_window = last_window.copy()

for _ in range(FORECAST_HOURS):

    pred_scaled = model.predict(
        np.array([current_window]),
        verbose=0
    )[0]

    future_predictions_scaled.append(pred_scaled)

    current_window = np.vstack((current_window[1:], pred_scaled))

future_predictions_scaled = np.array(future_predictions_scaled)

"""Inverse Scale Full Forecast"""

future_predictions = scaler.inverse_transform(future_predictions_scaled)

future_temp = future_predictions[:, temp_idx]

"""Plot Stable Forecast"""

plt.figure(figsize=(14,6))

historical_hours = 120

plt.plot(
    df_hourly['T (degC)'].iloc[-historical_hours:].values,
    label="Last 5 Days Actual"
)

future_index = range(historical_hours, historical_hours + FORECAST_HOURS)

plt.plot(
    future_index,
    future_temp,
    label="Next 7 Days Forecast"
)

plt.legend()
plt.title("7-Day Temperature Forecast (Multi-Output LSTM)")
plt.show()

#download the model
model.save('multivariate_dynamic.h5')

from google.colab import files
files.download("multivariate_dynamic.h5")